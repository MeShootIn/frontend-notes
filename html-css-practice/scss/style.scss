// КОММЕНТАРИИ

// Есть 3 вида:
// * Однострочные ("//") - не компилятся в CSS ("молчаливые" комментарии),
// потому что их там нет;
// * Многострочные ("/* */") - компилятся (но для компиляции в "сжатом" режиме
// надо "/*! */") => поддерживают интерполяцию;
// * Документационные ("///") - не компилятся, но их читает SassDoc
// (поддерживает все необходимые аннотаций).


// ФРАГМЕНТЫ И МОДУЛИ

// Директива "@use" работает только с Dart Sass (более быстрый и новый), для
// остальных юзать "@import".
// Каждый "@import" файла в CSS делает дополнительный HTTP-запрос, а Sass
// собирает всё в 1 файл.
// NOTE Если в папке есть файл "index.scss" (обычно являющийся главным), то
// можно просто прописать название папки ('@use "some_dir/common"' вместо '@use
// "some_dir/common/index"').
@use "sass:math" as mth;
@use "font";
// "@forward" позволяет экспортировать модуль в другой файл. Все переменные
// будут начинаться с префикса "font-".
@forward "font" as font-*;
// Экспортирует всё, кроме "$a-color".
@forward "font" hide $a-color;
// Экспортирует только "$a-color".
@forward "font" show $a-color;

// Импортирует все файлы в текущей директории в АЛФАВИТНОМ порядке.
// @use "*";

// Из пространства имён "font".
a {
  color: font.$a-color;
}


// ПЕРЕМЕННЫЕ

// Отличия от CSS-переменных:
// * в Sass они императивные (при изменении значения предыдущие не изменятся
// (обычное поведение));
// * в Sass переменная может иметь в один момент только 1 значение.

// "-" и "_" - эквивалентны => $font-size и $font_size - тоже.

// Принято писать в kebab-case.
$title-color: DarkBlue;
// Приватная переменная начинается с "-".
$-private-var: red;
// Поддерживается безымянная переменная: $_

.title {
  color: $title-color;
}


// ВЛОЖЕННОСТЬ

ul {
  li {
    font: 100% font.$font-stack;
  }
}


// МИКСИНЫ (ПРИМЕСИ)

// В отличие от расширений, ГЕНЕРИРУЮТСЯ ВСЕ и по отдельности (даже при
// отсутствии аргументов), потому что в языке они зашиты как динамические.
// Лучше не писать в миксине статичный поля, а выносить их в расширения (для
// экономии размера выходного файла).

%message {
  display: inline;
  padding: 5px;
}

@mixin message($message-color: blue, $border-color: black) {
  @extend %message;
  @extend %bold-black-font;

  border: 1px solid $border-color;
  background: rgba($message-color, 0.5);
}

.message {
  // "&" - конкатенация родительской строки с текущей (НЕ ТОЛЬКО с классом) =>
  // ".message_info".
  &_info {
    // Если без аргументов, то скобки можно опустить.
    @include message;
  }

  &_warning {
    @include message(yellow, blue);
  }

  &_error {
    // Именованные аргументы (можно менять порядок).
    @include message($border-color: yellow, $message-color: red);
  }

  // => CSS: .message .message__inner {...}
  // Лучше юзать для элементов
  #{&}__inner {
    background-color: black;
  }
}


// РАСШИРЕНИЯ

// Расширение (extend) - статичный блок. В выходном файле применяется ко
// всем затронутым селекторам, перечисленным через запятую => меньше кода =>
// меньше размер файла.

// Не отобразится в выходном CSS-файле, потому что нигде не юзается.
%extension_that_will_never_be_extended {
  z-index: 123456;
}

// Отобразится, потому что юзается в миксине "message".
%bold-black-font {
  font-weight: bold;
  color: black;
}


// МАТЕМАТИЧЕСКИЕ ОПЕРАТОРЫ

// Sass содержит несколько математических операторов (например, +, -, *,
// math.div(), и %). Для некоторых необходимо подключить модуль "sass:math".
article[role="main"] {
  width: mth.div(600px, 960px) * 100%;
}


// FIXME https://youtu.be/ZEUFnIwnj38?list=PL66qhubfOwjbRlOaIe1OEg_FhNP81cJ9G
// КОМПОНЕНТЫ И ФАЙЛОВАЯ СТРУКТУРА

// - styles
//     - css
//         - index.css
//         - article.css
//         - ...
//     - scss
//         - common (в порядке forward'ов, кроме _index.scss)
//             - _fonts.scss
//             - _reset.scss
//             - _variables.scss
//             - _extends.scss
//             - ...
//             - _common.scss
//             - _index.scss
//         - components
//             - header
//             - main
//             - footer
//             - ...
//         - index.scss (для index.html)
//         - article.scss (для article.html)
//         - ...

// Общие селекторы (из "common/common.scss") НЕ ВКЛАДЫВАТЬ в необщие. Например,
// нельзя:
.my-header {
  .container {
    // ...
  }
}


// TODO https://youtu.be/9uaENbRyVT4?list=PL66qhubfOwjbRlOaIe1OEg_FhNP81cJ9G
// РАБОТА С БРЕЙКПОИНТАМИ

// ИНТЕРПОЛЯЦИЯ

// Даёт возможность встраивать SCSS-выражения во фрагменты SCSS-кода. Юзается
// почти везде.

$breakpoint-mobile: 'sm';
$margin-side: 'top';

.logo-#{$breakpoint-mobile} {
  background-image: url("image/logo/#{$breakpoint-mobile}.jpg");
  margin-#{$margin-side}: 10px;
}

// Иногда полезно для CSS-переменных.
:root {
  --breakpoint-mobile: #{$breakpoint-mobile};
}


// УСЛОВИЯ

$theme-mode: 'dark';

@if ($theme-mode == 'light') {
  body {
    background-color: white;
  }
} @else if ($theme-mode == 'dark-light') {
  body {
    background-color: lightgray;
  }
} @else {
  body {
    background-color: darkgray;
  }
}


// СТРУКТУРЫ ДАННЫХ

// Список - набор значений через запятую. Обычно, юзается для перебора через
// циклы.
$colors: red, green, blue;

// Map - пары видов: ключ-значения / ключ-значение.
// Имя и нескольких значений:
$fonts: (
'regular' 400 red,
medium 500 green,
"bold" 700 blue,
);
// Явное указание одного значения (ПЛОХОЙ ТОН):
$breakpoints: (
sm: 576px,
md: 768px,
lg: 992px,
xl: 1200px,
xxl: 1400px,
);
// Получение значения:
.header-lg {
  max-width: map-get($breakpoints, 'lg');
}


// ЦИКЛЫ

// @each перебирает итерируемые объекты.

// По списку.
@each $color in $colors {
  .#{$color} {
    color: $color;
  }
}

// По мапе.
@each $name, $weight, $color in $fonts {
  .font-#{$name} {
    font-weight: $weight;
    color: $color;
  }
}

// По интервалу значений.
// [1, 6]
@for $i from 1 through 6 {
  .h#{$i} {
    font-weight: #{(7 - $i) * 100};
  }
}


// ФУНКЦИИ

// Как миксины, только могут содержать лишь языковые конструкции (циклы, списки,
// ...) и возвращают значения.

/// Computes an exponent.
///
/// @param {number} $base
///   The number to multiply by itself.
/// @param {integer (unitless)} $exponent
///   The number of `$base`s to multiply together.
/// @return {number} `$base` to the power of `$exponent`.
@function pow($base, $exponent) {
  $result: 1;

  @for $_ from 1 through $exponent {
    $result: $result * $base;
  }

  @return $result;
}

@function sum($numbers...) {
  $sum: 0;

  @each $number in $numbers {
    $sum: $sum + $number;
  }

  @return $sum;
}

.sm-plus-md {
  width: sum(
  map-get($breakpoints, 'sm'),
  map-get($breakpoints, 'md'),
  );
}
