/**
 * REACT
 */
/**
 * ВАЛИДНЫЙ JSX:
 * * string | number - рендерятся, boolean | null | undefined - НЕТ
 * * ReactElement
 * * ReactNode[]
 *
 * key нужен React’у для работы с массивами компонентов, чтобы понимать, как именно изменился массив между
 * рендерами.
 * key должен:
 * * Быть уникальным в рамках массива
 * * Не меняться для одного и того же элемента
 * * Быть string | number
 *
 * React не умеет работать с DOM. Он не знает про браузер.
 * React умеет строить свой, виртуальный DOM.
 * ReactDOM умеет работать с DOM и браузерами. Он знает,
 * как взять виртуальный DOM реакта и с минимумом усилий
 * превратить его в изменения в реальном DOM браузера.
 */
// Единственное место, где мы взаимодействуем с ним - index.js:
import ReactDOM from 'react-dom';

ReactDOM.render(<App/>, document.getElementById('root'));

// КОНСПЕКТИРОВАТЬ ТОЛЬКО ТО, ЧТО НЕПОНЯТНО
/**
 * Компоненты следует именовать с Больной буквы. Разница между компонентами и элементами - в именовании.
 *
 * КЛАССОВЫЕ КОМПОНЕНТЫ:
 * * Встречаются на просторах старого кода
 * * Все ещё умеют кое-что, чего не могут функциональные компоненты
 * * Логику хранят в методах жизненного цикла
 * * ДЛЯ МЕТОДОВ ИСПОЛЬЗОВАТЬ СТРЕЛОЧНЫЕ ФУНКЦИИ (кроме render()), иначе будет ошибка контекста
 * * Классовый setState не меняет объект целиком. Он подклеивает к существующему состоянию то, что мы
 * передали аргументом
 * Геттеры из setState({val: newVal}) находятся почти как в замыкании => не юзать несколько сеттеров в одном месте
 *
 * ФУНКЦИОНАЛЬНЫЕ КОМПОНЕНТЫ:
 * * Изначально предполагались как компоненты без состояния
 * и логики, но с изобретением хуков это изменилось
 * * Логику и состояние хранят в хуках
 * * Хуки пишутся прямо в функции
 * Геттеры из useState(val) находятся в замыкании => не юзать несколько сеттеров в одном месте, либо передавать
 * функцию: setCount(prevCount => prevCount + 1);
 *
 * В корне рендера может быть только 1 ReactNode => если нужно в корне больше 1-й ReactNode, но не хочется
 * оборачивать в лишние элементы - используйте фрагмент (<>...</>).
 *
 * У каждого компонента может быть локальное состояние.
 * * Локальным оно называется не просто так - оно
 * существует и меняется только в рамках компонента
 * * Приводит к перерисовке (перерендеру) компонента, если
 * изменяется, как и свойства
 * * В отличии от свойств, не передаётся в компонент извне
 * * У двух одинаковых компонентов состояние разное
 * Задаётся по-разному, в зависимости от типа компонента
 * * У функциональных - хук useState возвращает геттер и
 * сеттер состояния
 * У классовых - поле this.state и метод setState
 */

/**
 * ПЕРЕДАЧА ДАННЫХ
 *
 * Каждый компонент можно параметризовать свойствами.
 * * Свойства (props) - не состояние. Менять внутри
 * компонента нельзя.
 * * Приводит к перерисовке (перерендеру) компонента, если
 * в результате перерендера родителя пришли другие
 * * В отличии от состояния, передаётся в компонент извне
 * * Важно уметь не передавать новые свойства на каждом
 * рендере, если по сути они не меняются
 * * Есть зарезервированные свойства - children, ref и key
 *
 * Пропсы можно спредить, но не надо это делать без необходимости.
 * Дефолтные значения:
 * 1) Вы разрабатываете библиотеку компонентов, то у вас автоматически собирается документация на основе
 * defaultProps => можно их юзать
 * 2) Вы разрабатываете, компонент на проекте, в который будет смотреть коллега. Ему не нужно будет вспоминать,
 * что могут быть ещё и defaultProps => лучше хранить в константах, но придётся каждый раз при сеттинге писать
 * props.text ?? DEFAULTS.TEXT
 * 3) А можно: const Link = ({url = '...', text = 'текст'}) => (<a href={url}>{text}</a>);
 *
 * Не надо передавать константы в onClick={() => alert('Лишний ререндер')}, name='Pepe', ... Но можно:
 * props.urls.map((url) => 'https://' + url), т. к. (url) => {...} передаётся в map, а не в компонент. Лучше
 * юзать хуки useCallback и useMemo.
 */

/**
 * НЕКОНТРОЛИРУЕМЫЕ СОБЫТИЯ - нужны для оптимизации работы браузера TODO
 */